% Author: Victor Terron (c) 2013
% Email: `echo vt2rron1iaa32s | tr 132 @.e`
% License: GNU GPLv3

\documentclass[14pt]{beamer}

\usepackage[utf8]{inputenc}
\usepackage{listings}
\usepackage[T1]{fontenc}

% Reduce space between image and caption; also remove prefix 'Figure:'
% http://tex.stackexchange.com/a/94018
% http://tex.stackexchange.com/a/82462
\usepackage[font=small,skip=1pt,labelformat=empty]{caption}

% New line between paragraphs, no indentation
% http://tex.stackexchange.com/q/42
\usepackage[parfill]{parskip}

\usetheme{Copenhagen}
\useoutertheme{infolines}
\setbeamercovered{dynamic}
\setbeamertemplate{navigation symbols}{} % remove navigation symbols

\lstset{basicstyle=\ttfamily,language=python}

% Remove the space symbol for code inside the double quotation marks
% http://www.latex-community.org/viewtopic.php?f=4&t=248
\lstset{showstringspaces=false}

% Enable accents and ñ in our code listings
% http://stackoverflow.com/a/2782147/184363
\lstset{
  literate={á}{{\'a}}1
           {é}{{\'e}}1
           {í}{{\'i}}1
           {ó}{{\'o}}1
           {ú}{{\'u}}1
           {ñ}{{\~n}}1
           {¡}{{\textexclamdown}}1
}

\definecolor{red}{HTML}{F41B1B}
\definecolor{blue}{HTML}{2E3CEC}
\definecolor{green}{HTML}{3C8031}

% Beamer: footer with current slide number but not total slide number
% http://tex.stackexchange.com/a/32815
\makeatletter
\setbeamertemplate{footline}
{
  \leavevmode%
  \hbox{%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,center]{author in head/foot}%
    \usebeamerfont{author in head/foot}\insertshortauthor~~\beamer@ifempty{\insertshortinstitute}{}{(\insertshortinstitute)}
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,center]{title in head/foot}%
    \usebeamerfont{title in head/foot}\insertshorttitle
  \end{beamercolorbox}%
  \begin{beamercolorbox}[wd=.333333\paperwidth,ht=2.25ex,dp=1ex,right]{date in head/foot}%
    \usebeamerfont{date in head/foot}\insertshortdate{}\hspace*{2em}
    \insertframenumber\hspace*{2ex}
  \end{beamercolorbox}}%
  \vskip0pt%
}
\makeatother

\title{["Python"] * 40}
\author{Víctor Terrón}
\date{23 de noviembre de 2013}
\institute{IAA-CSIC}

\begin{document}

\begin{frame}
  \titlepage

  \begin{figure}
    \vspace{-0.5cm}
    \includegraphics[width=2cm]{pics/mistery-box.jpg}
  \end{figure}

  \footnotesize
  \begin{center}
    Cuarenta características de Python que \structure{quizás} no conoces
  \end{center}

\end{frame}

\section{Introducción}

\begin{frame}{Unknown Unknowns}
  \small
  \begin{block}{}
    \centering
    ``There are things we know that we know. There are known
    unknowns. That is to say there are things that we now know we
    don't know. But there are also \structure{unknown unknowns}. There
    are things we do not know we don't know'' [Donald Rumsfeld, 2002]
  \end{block}

  \small
  \begin{itemize}
    \item En Python hay funcionalidades increíbles,
     \structure{imprescindibles una vez que las conoces}, que
     podríamos no echar en falta jamás porque ni siquiera sabíamos
     que existían.
    \item El propósito de esta charla es presentar una serie de
      aspectos interesantes de Python que en estos años he descubierto
      que mucha gente, incluso programadores veteranos, desconoce.
  \end{itemize}
\end{frame}

\begin{frame}{Unknown Unknowns}
  \begin{itemize}
    \item Algunas de las funcionalidades que vamos a discutir aquí son
      muy prácticas y otras curiosidades de indiscutiblemente escasa o
      nula utilidad en nuestro día a día. Pero todos ellos son
      conceptos \structure{sencillos de entender} y que merece la pena
      saber que están ahí, incluso si no los usamos... por ahora.
    \item Tenemos 1:15 minutos para cada uno de los puntos, así que
      muchos de ellos sólo vamos a poder \structure{verlos muy por
      encima}. Pero al menos habrán dejado de ser \emph{unknown
      unknowns}.
  \end{itemize}
\end{frame}

\begin{frame}{¡No os limitéis a escuchar!}
  \begin{center}
    No suele ser divertido escuchar a nadie hablar durante casi una
    hora. Participad, intervenid, criticad, opinad. ¡Si digo algo que
    no tiene ningún sentido, \structure{corregidme}!
  \end{center}

  \begin{block}{\centering El código fuente está disponible en:}
    \centering \url{http://github.com/vterron/PyConES-2013}
  \end{block}

  \begin{center}
    \small Erratas, correcciones, enlaces interesantes...\\ ¿enviará
    alguien algún pull request antes de que termine esta charla?
  \end{center}
\end{frame}

\begin{frame}{}
  \begin{alertblock}{}
    \centering \Large ¿Listos?
  \end{alertblock}

  \begin{figure}
    \centering
    \includegraphics[height=6cm]{pics/a-clockwork-orange.jpg}
  \end{figure}
\end{frame}

\section{Los diez primeros}

\input{01.tex}
\input{02.tex}
\input{03.tex}
\input{04.tex}
\input{05.tex}
\input{06.tex}
\input{07.tex}
\input{08.tex}
\input{09.tex}
\input{10.tex}

\section{Los diez siguientes}

\input{11.tex}
\input{12.tex}
\input{13.tex}
\input{14.tex}
\input{15.tex}
\input{16.tex}
\input{17.tex}
\input{18.tex}
\input{19.tex}
\input{20.tex}

\section{}

\begin{frame}{}
  \begin{block}{}
    \centering \Large Respira profundamente
  \end{block}

  \begin{figure}
    \centering
    \includegraphics[height=6cm]{pics/a-clockwork-orange-2.jpg}
  \end{figure}
\end{frame}

\section{Diez más}

\input{21.tex}
\input{22.tex}
\input{23.tex}

\begin{frame}[fragile]{24. *args y **kwargs}
  \begin{block}{}
    \small
    \centering
    Nuestras funciones pueden recibir un \structure{número variable}
    de argumentos.
  \end{block}

  \begin{exampleblock}{}
    \footnotesize
    \begin{lstlisting}
>>> def imprime_punto2D(x, y):
...     print "({0}, {1})".format(x, y)
...
>>> def imprime_punto3D(x, y, z):
...     print "({0}, {1}, {2})".format(x, y, z)
...
>>> imprime_punto2D(1, 2)
(1, 2)
>>> imprime_punto3D(4, 3, 3)
(4, 3, 3)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{24. *args y **kwargs}
  \begin{block}{}
    \small
    \centering
    Podríamos generalizarlo a cualquier número de dimensiones:
  \end{block}

  \begin{exampleblock}{}
    \scriptsize
    \begin{lstlisting}
>>> def imprime_punto(coords):
...     print "({0})".format(", ".join(str(x) for x in coords))
...
>>> imprime_punto([1, 2])
(1, 2)
>>> imprime_punto([1, 2, 3, 4])
(1, 2, 3, 4)
    \end{lstlisting}
  \end{exampleblock}

  \begin{alertblock}{}
    \small
    \centering
    Pero esto nos obliga a pasar las coordenadas \structure{en una
      secuencia}.
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]{24. *args y **kwargs}
  \begin{block}{}
    \small
    \centering
    Añadiendo \structure{un asterisco} al nombre del parámetro cuando
    definimos la función podemos hacer que Python los
    \structure{agrupe} todos a partir de ese punto en una tupla.
  \end{block}

  \begin{exampleblock}{}
    \scriptsize
    \begin{lstlisting}
>>> def imprime_punto(*coords):
...     print "coordenadas: ", coords
...     print "({0})".format(", ".join(str(x) for x in coords))
...
>>> imprime_punto(2, 4)
coordenadas: (2, 4)
(2, 4)
>>> imprime_punto(1, 3, 2)
coordenadas: (1, 3, 2)
(1, 3, 2)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{24. *args y **kwargs}
  \begin{block}{}
    \centering
    Los parámetros listados \structure{antes} del que tiene el
    asterisco se comportan normalmente.
  \end{block}

  \begin{exampleblock}{}
    \scriptsize
    \begin{lstlisting}
>>> def imprime(x, y, *resto):
...     print "x:", x
...     print "y:", y
...     print "resto:", resto
...
>>> imprime(1, 2, 3, 7)
x: 1
y: 2
resto: (3, 7)
>>> imprime(5, 3)
x: 5
y: 3
resto: ()
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{24. *args y **kwargs}
  \begin{block}{}
    \small
    \centering
    A la inversa, podemos usar el asterisco al llamar una función para
    \structure{desempaquetar} una sequencia y asignar sus elementos,
    uno a uno, a los diferentes parámetros que la función recibe.
  \end{block}

  \begin{exampleblock}{}
    \scriptsize
    \begin{lstlisting}
>>> def imprime_punto2D(x, y):
...     print "({0}, {1})".format(x, y)
...
coords = (4, 5)
>>> imprime_punto2D(coords)
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: imprime_punto2D() takes exactly 2 arguments (1 given)
>>> imprime_punto2D(*coords)
(4, 5)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{24. *args y **kwargs}
  \begin{alertblock}{}
    \small
    \centering
    Lo mismo puede hacerse, pero usando el \structure{doble
      asterisco}, con los argumentos nombrados (\emph{keyword
      arguments}): Python \structure{agrupa} todos los que recibe en
    un diccionario.
  \end{alertblock}

  \begin{exampleblock}{}
    \scriptsize
    \begin{lstlisting}
>>> def imprime_punto(**coordenadas):
...     print "coordenadas: ", coordenadas
...     for clave, valor in coordenadas.items():
...         print "{0} = {1}".format(clave, valor)
...
>>> imprime
_punto(x = 4, y = 8)
coordenadas:  {'y': 8, 'x': 4}
y = 8
x = 4
>>> imprime_punto(z = 3, x = 7, y = 2)
coordenadas:  {'y': 2, 'x': 7, 'z': 3}
y = 2
x = 7
z = 3
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{24. *args y **kwargs}
  \begin{block}{}
    \small
    \centering
    Y, también, a la hora de llamar a una función podemos usar
    \structure{**} para \structure{desempaquetar} un diccionario y
    pasar cada uno de sus elementos como un argumento nombrado.
  \end{block}

  \begin{exampleblock}{}
    \scriptsize
    \begin{lstlisting}
>>> def imprime_punto2D(x = 0, y = 0):
...     print "x = {0}".format(x)
...     print "y = {0}".format(y)
...
>>> coords = {'x' : 1}
>>> imprime_punto2D(**coords)
x = 1
y = 0
>>> coords = {'x' : 3, 'y' : 7}
>>> imprime_punto2D(**coords)
x = 3
y = 7
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{24. *args y **kwargs}
  \begin{block}{}
    \small
    \centering
    Es habitual usar \structure{*args} y \structure{**kwargs} como
    nombres de variables cuando definimos una función que recibe un
    número variable de parámetros o parámetros nombrados,
    respectivamente.
  \end{block}

  \footnotesize
  \begin{block}
    {\centering
      En GiHub hay 710K+ ejemplos en los que se usa esa notación:}
    \centering
    \url{https://github.com/search?l=python&q=*args\%2C+**kwargs&ref=searchresults&type=Code}
  \end{block}

\begin{block}
    {\centering
      Magnus Lie Hetland — Beginning Python \\
      Collecting Parameters (capítulo 6, "Abstraction")
    }
    \centering \url{http://hetland.org/writing/beginning-python-2/}
  \end{block}
\end{frame}

\begin{frame}[fragile]{25. for-else}
  \begin{block}{}
    \centering
    \small
    El bucle \structure{for} admite, opcionalmente, la cláusula
    \structure{else}: este bloque se ejecuta sólo si el bucle for ha
    terminado \emph{limpiamente} --- es decir, si \structure{no} se ha
    usado \structure{break} para terminar antes de tiempo.
  \end{block}

  \small
  \begin{exampleblock}
    {No usamos break, else se ejecuta}
    \begin{lstlisting}
>>> for x in range(3):
...     print x
... else:
...     print "¡Hemos terminado!"
...
0
1
2
¡Hemos terminado!
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{25. for-else}
  \small
  \begin{exampleblock}
    {Usamos break, else no se ejecuta}
    \begin{lstlisting}
>>> for x in range(3):
...     print x
...     break
... else:
...     print "¡Hemos terminado otra vez!"
...
0
    \end{lstlisting}
  \end{exampleblock}

  \begin{alertblock}{}
    \centering
    Esta construcción, for-else, nos ahorra la necesidad de usar una
    \structure{variable de bandera} para almacenar el estado de, por
    ejemplo, una búsqueda.
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]{25. for-else}
  \footnotesize
  \begin{block}{}
    \centering
    Para lanzar una excepción si un elemento \structure{no ha sido
      encontrado} en una secuencia, por ejemplo, podríamos usar una
    variable que fuera \structure{False} y que, sólo si en algún
    momento encontramos el elemento a buscar, pasamos a
    \structure{True}. Al terminar el bucle, actuamos en función del
    valor de esta variable.
  \end{block}

  \begin{exampleblock}{}
    \scriptsize
    %Escape triple quotes; otherwise string is italicized
    \begin{lstlisting}[escapechar=!]
def comprueba_que_esta(x, secuencia):
    !"""! Lanza ValueError si x no está en la secuencia !"""!

    encontrado = False
    for elemento in secuencia:
    if elemento == x:
        encontrado = True
        break

    if not encontrado:
        msg = "{0} no está en {1}".format(x, secuencia)
        raise ValueError(msg)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{25. for-else}
  \begin{block}{}
    \centering
    La cláusula \structure{else} nos permite escribirlo así:
  \end{block}

  \begin{exampleblock}{}
    \scriptsize
    \begin{lstlisting}
def comprueba_que_esta(x, secuencia):
    for elemento in secuencia:
    if elemento == x:
            break
    else:
        msg = "{0} no está en {1}".format(x, secuencia)
        raise ValueError(msg)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{25. for-else}
  \begin{alertblock}{}
    \centering
    Los bucles \structure{while} también admiten la cláusula
    \structure{else}.
  \end{alertblock}

  \footnotesize
  Hay a quien no convence el nombre --- y no sin motivo: de
  primeras, podríamos creer que else sólo se ejecuta si el bucle for
  no llega a ejecutarse nunca. Las razones detrás de este nombre son
  históricas, por cómo los compiladores implementaban los bucles
  while.

  La forma de visualizar el else es que casi siempre está
  \structure{emparejado} con un \structure{if}: el que está dentro del
  bucle \structure{for}. Lo que estamos diciendo es "\emph{si ninguna
    de las veces el if dentro del for es cierta, entonces ejecuta el
    bloque de else}".

  \begin{block}
    {\centering Ned Batchelder: For/else}
    \centering \url{http://nedbatchelder.com/blog/201110/forelse.html}
  \end{block}
\end{frame}

\begin{frame}[fragile]{26. try-except-else-finally}
  \begin{alertblock}{}
    \centering
    La construcción \structure{try-except-finally} admite también la
    cláusula \structure{else}: este bloque de código se ejecuta sólo
    si no se ha lanzado ninguna excepción.
  \end{alertblock}

  \begin{center}
    \small
    Esto nos permite minimizar el código que escribimos dentro de la
    cláusula \structure{try}, reduciendo el riesgo de que
    \structure{except} capture una excepción que realmente no
    queríamos proteger con el \structure{try}.
  \end{center}
\end{frame}

\begin{frame}[fragile]{26. try-except-else-finally}
  \begin{exampleblock}
    {\footnotesize
      Descarga presentación, descomprime, actualiza log}
    \tiny
    \begin{lstlisting}[escapechar=!]
import os
import urllib
import zipfile

url = "http://github.com/vterron/PyConES-2013/archive/master.zip"
path = "charla-pycon.zip"

try:
    urllib.urlretrieve(url, path)
    myzip = zipfile.ZipFile(path)
    myzip.extractall()  # puede lanzar !\color{red}{IOError}!

    # Tambien puede lanzar !\color{red}{IOError}!
    with open("descargas-log", "at") as fd:
        fd.write("{0}\n".format(path))

except !\color{red}{IOError}!:
    print "He capturado IOError!"

finally:
    os.unlink(path)
    \end{lstlisting}
  \end{exampleblock}

  \small
  \begin{alertblock}{}
    \centering
    ¿Cuál de los dos \structure{IOError} he capturado?
    \structure{No lo sabemos}
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]{26. try-except-else-finally}

  \begin{exampleblock}
    {\footnotesize
      Por supuesto, podríamos evitar este problema anidando try-elses:}
    \tiny
    \begin{lstlisting}
try:
    urllib.urlretrieve(url, path)
    myzip = zipfile.ZipFile(path)
    try:
        myzip.extractall()
	try:
            with open("descargas-log", "at") as fd:
                fd.write("{0}\n".format(path))
        except IOError:
            print "Error escribiendo fichero"

    except IOError:
        print "Error descomprimiendo fichero ZIP"

finally:
    os.unlink(path)
    \end{lstlisting}
  \end{exampleblock}

  \small
  \begin{alertblock}{}
    \centering
    Pero, como dice el Zen de Python, "\emph{Flat is better than nested}"
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]{26. try-except-else-finally}
  \begin{block}{}
    \centering
    Utilizando la cláusula \structure{else} basta con:
  \end{block}

  \begin{exampleblock}{}
    \footnotesize
    \begin{lstlisting}[escapechar=!]
try:
    urllib.urlretrieve(url, path)
    myzip = zipfile.ZipFile(path)
    myzip.extractall()
except IOError:
    print "Error descomprimiendo fichero ZIP"
!\color{red}{else:}!
    with open("descargas-log", "at") as fd:
        fd.write("{0}\n".format(path))
finally:
    os.unlink(path)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{27. Relanzamiento de excepciones}
  \small
  \begin{block}{}
    \centering
    \structure{raise} a secas, dentro del bloque de la cláusula
    \structure{except}, relanza la excepción con la traza (traceback)
    original intanta. Esto es muy útil si queremos hacer algo más
    antes de lanzar la excepción.
  \end{block}

  \begin{exampleblock}{}
    \scriptsize
    \begin{lstlisting}[escapechar=!]
>>> x = 1
>>> y = 0
>>> try:
...     z = x / y
... except ZeroDivisionError:
...     print "Imposible dividir. Abortando..."
...     !\color{blue}{raise}!
...
Imposible dividir. Abortando...
Traceback (most recent call last):
  File "<stdin>", line 2, in <module>
ZeroDivisionError: integer division or modulo by zero
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{27. Relanzamiento de excepciones}
  \footnotesize
  \begin{alertblock}{}
    \centering
    Pero, claro, raise relanza la \structure{última} excepción. En
    caso de que dentro del \structure{except} exista la posibilidad de
    que se lance una segunda excepción, podemos almacenarla para
    asegurarnos de que no la perdemos.
  \end{alertblock}

  \begin{exampleblock}
    {En Python 3000:}
    \tiny
    \begin{lstlisting}[escapechar=!]
import os

try:
    path = "resultado.txt"
    with open(path, "wt") as fd:
        resultado = 1 / 0
        fd.write(str(resultado))

except BaseException !\color{blue}{as e}!:

    try:
        os.unlink(path)
    except Exception as sub_e:
        print("Ha ocurrido otro error:")
        print(sub_e)

    !\color{blue}{raise e}!
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{27. Relanzamiento de excepciones}
  \footnotesize
  \begin{exampleblock}
    {Esto produce:}
    \begin{lstlisting}[escapechar=!]
>>> python3.1 relanza-excepcion.py
Ha ocurrido otro error:
[Errno 13] Permission denied: '/root/.bashrc'
Traceback (most recent call last):
  File "relanza.py", line 18, in <module>
    raise e
  File "relanza.py", line 8, in <module>
    resultado = 1 / 0
ZeroDivisionError: int division or modulo by zero
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{27. Relanzamiento de excepciones}
  \small
  \begin{block}{}
    \centering
    En Python 2 también podemos usar la notación except
    \structure{Exception, e} (sin los paréntesis), pero desde 2.6+ la
    keyword \structure{as} permite que nuestro código sea mucho menos
    ambiguo.
  \end{block}

  \begin{block}
    {\centering Python try...except comma vs 'as' in except}
    \centering \url{http://stackoverflow.com/a/2535770/184363}
  \end{block}

    \begin{block}
    {\centering PEP 3110: Catching Exceptions in Python 3000:}
    \centering \url{http://www.python.org/dev/peps/pep-3110/}
  \end{block}
\end{frame}

\begin{frame}{28. \_\_str\_\_() vs \_\_repr\_\_()}

  \footnotesize
  \begin{alertblock}
    {\centering
      \small
      El objetivo de \_\_repr\_\_() es ser inequívoco.
    }
    \centering

    {Este método, ejecutado vía \structure{repr()}, devuelve una
      cadena de texto con la \structure{representación única del
        objeto}. Se usa sobre todo para depurar errores, por lo que la
      idea es que incluya toda la información que necesitamos --- por
      ejemplo, intentando entender qué ha fallado analizando unos
      logs.  }
  \end{alertblock}

  \begin{block}
    {\centering
      \small
      El objetivo de \_\_str\_\_() es ser legible.
    }
    \centering
    {\footnotesize
      La cadena que devuelve \structure{str()} no tiene otro fin que
      el de ser fácil de comprender por \structure{humanos}: cualquier
      cosa que aumente la legibilidad, como eliminar decimales
      inútiles o información poco importante, es aceptable.
    }
  \end{block}
\end{frame}

\begin{frame}[fragile]{28. \_\_str\_\_() vs \_\_repr\_\_()}
  \footnotesize
  \begin{exampleblock}
    {El módulo datetime nos proporciona un buen ejemplo:}
    \begin{lstlisting}
>>> import datetime
>>> today = datetime.datetime.now()
>>> str(today)
'2013-11-20 13:51:53.006588'
>>> repr(today)
'datetime.datetime(2013, 11, 20, 13, 51, 53, 6588)'
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{28. \_\_str\_\_() vs \_\_repr\_\_()}
  \small
  \begin{block}{}
    \centering
    Idealmente, la cadena devuelta por \structure{\_\_repr\_\_()}
    debería ser aquella que, pasada a \structure{eval()}, devuelve el
    mismo objeto. Al fin y al cabo, si \structure{eval()} es capaz de
    reconstruir el objeto a partir de ella, esto garantiza que
    contiene \structure{toda} la infomación que necesaria:
  \end{block}

  \footnotesize
  \begin{exampleblock} {}
    \begin{lstlisting}
>>> today = datetime.datetime.now()
>>> repr(today)
'datetime.datetime(2013, 11, 20, 13, 54, 33, 934577)'
>>> today == eval(repr(today))
True
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}{28. \_\_str\_\_() vs \_\_repr\_\_()}
  \begin{alertblock}{}
    \centering
    Por cierto, ¡usar \structure{eval(repr(obj))} para serializar
    objetos no es buena idea! Es poco eficiente y, mucho peor,
    peligroso. Usa \structure{pickle} mejor.
  \end{alertblock}

  \small
  \begin{block}
    {\centering Eval really is dangerous:}
    \centering \url{http://nedbatchelder.com/blog/201206/eval_really_is_dangerous.html}
  \end{block}
\end{frame}

\begin{frame}{28. \_\_str\_\_() vs \_\_repr\_\_()}
  \small
  \begin{alertblock}{}
    \centering
    \_\_repr\_\_() es para \structure{desarrolladores},
    \_\_str\_\_() para \structure{usuarios}.
  \end{alertblock}

  \begin{block}{}
    \centering
    En caso de que nuestra clase defina \_\_repr\_\_() pero no
    \_\_str\_\_(), la llamada a \structure{str() también devuelve
    repr()}. Así que el único que de verdad tenemos que
    implementar es \_\_repr\_\_().
  \end{block}

  \begin{block}
    {\centering Difference between \_\_str\_\_ and \_\_repr\_\_ in Python:}
    \centering \url{http://stackoverflow.com/q/1436703/184363}
  \end{block}
\end{frame}

\begin{frame}
  {29. \normalsize Implementando \_\_hash\_\_() en nuestras clases}
  \small
  \begin{block}{}
    \centering
    El método \structure{\_\_hash\_\_()} devuelve un entero que
    representa el valor hash del objeto. Es lo que se usa en los
    diccionarios, por ejemplo, para relacionar cada clave con su valor
    asociado. El único requisito es que los objetos que se consideren
    \structure{iguales} (==) han de devolver también el
    \structure{mismo valor hash}.
  \end{block}

  \begin{alertblock}{}
    \centering
    En caso de que no definamos \structure{\_\_hash\_\_()}, nuestras
    clases devuelven \structure{id()} -- un valor único para cada
    objeto, ya que es su dirección en memoria.
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]
  {29. \normalsize Implementando \_\_hash\_\_() en nuestras clases}
  \tiny
  \begin{exampleblock}{}
    \begin{lstlisting}
class Punto(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y

p1 = Punto(1, 7)
p2 = Punto(2, 3)
p3 = Punto(2, 3)

print "id(p1)  : ", id(p1)
print "hash(p1): ", hash(p1)
print "hash(p2): ", hash(p2)
print "hash(p3): ", hash(p3)
    \end{lstlisting}
  \end{exampleblock}

  \begin{exampleblock}
    {\scriptsize
      Esto muestra por pantalla, por ejemplo:}
    \begin{lstlisting}[escapechar=!]
id(p1)  :  140730517360144
hash(p1):  140730517360144
hash(p2):  140730516993!\color{red}{872}!
hash(p3):  140730516993!\color{red}{936}!
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  {29. \normalsize Implementando \_\_hash\_\_() en nuestras clases}
  \footnotesize
  \begin{block}{}
    \centering
    Una forma de calcular el hash de nuestra clase, en los casos que
    no son demasiado complejos, es devolver el \structure{hash de una
      tupla que agrupa los atributos de nuestra clase}. Rápido y
    sencillo:
  \end{block}

  \scriptsize
  \begin{exampleblock} {}
    \begin{lstlisting}
class Punto(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __hash__(self):
        return hash((self.x, self.y))

p1 = Punto(3, 9)
p2 = Punto(3, 9)

print "id(p1)  : ", id(p1)
print "id(p2)  : ", id(p2)
print "hash(p1): ", hash(p1)
print "hash(p2): ", hash(p2)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]
  {29. \normalsize Implementando \_\_hash\_\_() en nuestras clases}
  \small
  \begin{exampleblock}
    {Ejecutado, esto muestra:}
    \begin{lstlisting}
id(p1)  :  140050627503952
id(p2)  :  140050627504016
hash(p1):  3713083797000648531
hash(p2):  3713083797000648531
    \end{lstlisting}
  \end{exampleblock}

  \footnotesize
  \begin{block}
    {\centering Python: What's a correct and good way to implement \_\_hash\_\_()?}
    \centering \url{http://stackoverflow.com/q/2909106/184363}
  \end{block}
\end{frame}

\begin{frame}
  {29. \normalsize Implementando \_\_hash\_\_() en nuestras clases}
  \small
  \begin{alertblock}{}
    \centering
    En caso de que dos objetos devuelvan el mismo hash, aún podemos
    usarlos en diccionarios. Esto es así porque los elementos se
    indexan no sólo por su valor hash, sino que Python
    \structure{también comprueba que no son iguales} (==). Es sólo si
    son iguales en los dos sentidos que los dos objetos no pueden
    existir en el mismo diccionario.
  \end{alertblock}

  \footnotesize
  \begin{block}
    {\centering Difference between \_\_str\_\_ and \_\_repr\_\_ in Python:}
    \centering \url{http://stackoverflow.com/q/1436703/184363}
  \end{block}

  \begin{block}
    {\centering How hash collisions are resolved in Python dictionaries}
    \centering \url{http://www.shutupandship.com/2012/02/how-hash-collisions-are-resolved-in.html}
  \end{block}
\end{frame}

\begin{frame}{30. \{\} y dict()}
  \begin{center}
    \centering
    \small
    Habitualmente los \structure{diccionarios} se contruyen usando \structure{{}}
  \end{center}

  \begin{block}{}
    \Large
    \centering {'uno': 1, 'dos': 2, 'tres': 3}
  \end{block}

  \vspace{0.5cm}

  \begin{center}{}
    \centering
    \small
    También podemos hacerlo, sin embargo, utilizando
    \structure{dict()}. Esto tiene la ventaja de que podemos definir
    los elementos del diccionario como \structure{argumentos
      nombrados} --- esto nos ahorra tener que poner comillas
    alrededor de las claves que sean cadenas de texto:
  \end{center}

  \begin{block}{}
    \Large
    \centering dict(uno = 1, dos = 2, tres = 3)
  \end{block}
\end{frame}

\begin{frame}[fragile]{30. \{\} y dict()}
  \small
  \begin{block}{}
    \centering
    Una \structure{limitación de dict()} es que las claves de nuestro
    diccionario sólo pueden ser identificadores (nombres de variable)
    \structure{válidos} en Python. Por el contrario, \structure{\{\}}
    admite cualquier identificador.
  \end{block}

  \footnotesize
  \begin{exampleblock}
    {Esto es perfectamente legal}
    \begin{lstlisting}
>>> d = {1 : "uno", 2 : "dos", 3 : "tres"}
>>> d[1]
'uno'
    \end{lstlisting}
  \end{exampleblock}

  \begin{exampleblock}
    {Pero un entero no es un nombre de variable válido:}
    \begin{lstlisting}
>>> dict(1 = "uno", 2 = "dos", 3 = "tres")
  File "<stdin>", line 1
SyntaxError: keyword can't be an expression
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{30. \{\} y dict()}
  \begin{alertblock}{}
    \centering
    Esto es, en esencia, \structure{una cuestión de estilo} -- hay
    quien lo considera más cómodo y legible, pero dict() también tiene
    sus detractores.
  \end{alertblock}

  \vspace{0.5cm}

  \footnotesize
  \begin{center}
    \centering
    Doug Hellmann, por ejemplo, ha cuantificado que es seis veces más
    lento que {}, y que consume más memoria.
  \end{center}

  \footnotesize
    \begin{block}
    {\centering The Performance Impact of Using dict() Instead of {} in CPython 2.7}
    \centering
    \url{http://doughellmann.com/2012/11/the-performance-impact-of-using-dict-instead-of-in-cpython-2-7-2.html}
  \end{block}
\end{frame}

\section{Recordatorio}
\begin{frame}[fragile]{A veces nos sentimos así}
  \begin{figure}
    \centering
    \includegraphics[height=6cm]{pics/un-palo.jpg}
  \end{figure}
\end{frame}

\section{Los últimos diez}

\begin{frame}[fragile]{31. dict.\_\_missing\_\_()}
  \small
  \begin{block}{}
    \centering
    En las \structure{subclases} de dict que definen
    \structure{\_\_missing\_\_()}, el acceso a claves que no estén
    presentes en el diccionario devuelve lo que este método devuelva.
  \end{block}

  \scriptsize
  \begin{exampleblock}{}
    % Escape triple quotes; otherwise string is italicized
    \begin{lstlisting}[escapechar=!]
class MyDict(dict):
    !"""! Diccionario que devuelve -1 si la clave no existe !"""!

    def __missing__(self, key):
        print "'{0}' no encontrado".format(key)
        return -1

>>> d = MyDict()
>>> d[1] = 3
>>> d[1]
3
>>> d[5]
'5' no encontrado
-1
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{31. dict.\_\_missing\_\_()}
  \small
  \begin{alertblock}{}
    \centering
    \_\_missing\_\_() \structure{no puede ser una variable} -- ha de ser un
    método, que recibirá como argumento la clave que no se ha
    encontrado.
  \end{alertblock}

  \scriptsize
  \begin{exampleblock}
    {\footnotesize Algo que no va a funcionar:}
    \begin{lstlisting}[escapechar=!]
class MyDict(dict):
    !"""! Diccionario que devuelve -1 si la clave no existe !"""!

    __missing__ = -1

>>> d = MyDict()
>>> d[7]
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
TypeError: 'int' object is not callable
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{32. collections.defaultdict}
  \small
  \begin{block}{}
    \centering
    Normalmente es mucho mejor, no obstante, usar
    \structure{defaultdict}: se comporta como un diccionario a todos
    con los efectos, con la única diferencia de que al crearlo
    especificamos \structure{el valor que tendrán por defecto} las
    claves a las que accedamos que no existan.
  \end{block}

  \footnotesize
  \begin{exampleblock}
    {Para implementar un contador, en vez de hacer esto...}
    \begin{lstlisting}
mydict == dict()
for letra in palabra:
    if letra in mydict:
        mydict[elemento] += 1
    else:
        mydict[elemento] == 1
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{32. collections.defaultdict}
  \footnotesize
  \begin{exampleblock}
    {... o incluso esto...}
    \begin{lstlisting}
mydict == dict()
for letra in palabra:
    try:
        mydict[elemento] += 1
    except KeyError:
        pass
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{32. collections.defaultdict}
  \footnotesize
  \begin{exampleblock}
    {Mucho mejor así:}
    \begin{lstlisting}
import collections
mydict = collections.defaultdict(int)
for letra in palabra:
    mydict[elemento] += 1
    \end{lstlisting}
  \end{exampleblock}

  \small
  \begin{alertblock}{}
    \centering
    ¡Pero esto es sólo un ejemplo! En código real \structure{nunca}
    implementéis un contador así! Lo tenéis ya hecho por gente mucho
    más capaz que nosotros, y disponible desde Python 2.7, en este
    mismo módulo:
    \structure{collections.Counter}.
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]{32. collections.defaultdict}
  \small
  \begin{exampleblock}
    {Valor por defecto: []}
    \begin{lstlisting}
collections.defaultdict(list)
    \end{lstlisting}
  \end{exampleblock}

  \small
  \begin{exampleblock}
    {Valor por defecto: set()}
    \begin{lstlisting}
collections.defaultdict(set)
    \end{lstlisting}
  \end{exampleblock}

  \begin{exampleblock}
    {Valor por defecto: \{\}}
    \begin{lstlisting}
d = collections.defaultdict(dict)
d[0][3] = 3.43
d[1][5] = 1.87
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{32. collections.defaultdict}
  \small
  \begin{block}{}
    \centering
    Pasar usar valores por defecto \structure{diferentes de cero o
      vacíos}, tenemos que tener presente que lo que
    defaultdict.\_\_init\_\_() recibe es \structure{una función} que
    acepta cero argumentos, que es la que se ejecuta cada vez que la
    clave no se encuentra.
  \end{block}

  \begin{exampleblock}
    {Valor por defecto: -7}
    \begin{lstlisting}
collections.defaultdict(lambda: -7)
    \end{lstlisting}
  \end{exampleblock}

  \begin{exampleblock}
    {Valor por defecto: números [1, 7]}
    \begin{lstlisting}
collections.defaultdict(lambda: range(8))
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{33. collections.namedtuple}
  \small
  \begin{block}{}
    \centering
    Devuelve un tipo de dato, subclase de \structure{tuple}, que
    podemos usar para crear tuplas que además nos permiten acceder
    también por atributos.  Con \structure{namedtuple} estamos
    definiendo nuestra propia clase en una línea de código -- no deja
    de estar bien, aunque sean clases sencillas.
  \end{block}

  \scriptsize
  \begin{exampleblock}
    {\footnotesize La clase Punto(x, y, z)}
    \begin{lstlisting}
>>> Punto = collections.namedtuple('Punto', ['x', 'y', 'z'])
>>> Punto.__mro__
(<class '__main__.Punto'>, <type 'tuple'>, <type 'object'>
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{33. collections.namedtuple}
  \small
  \begin{exampleblock}
    {Y ahora usándola:}
    \begin{lstlisting}
>>> dest = Punto(1, 4, 3)
>>> dest.x
1
>>> dest.y
4
>>> dest[2]
3
    \end{lstlisting}
  \end{exampleblock}

  \begin{block}
    {\centering Understanding Python's iterator, iterable, and iteration protocols}
    \centering \url{http://stackoverflow.com/q/9884132/184363}
  \end{block}
\end{frame}

\begin{frame}[fragile]{34. itertools.chain()}
  \small
  \begin{block}{}
    \centering
    La función \structure{chain()}, del módulo \structure{itertools},
    crea un \structure{iterador} que devuelve, uno a uno, elementos de
    cada uno de los iterables que recibe, recorriéndolos todos.
  \end{block}

  \footnotesize
  \begin{exampleblock}{}
    \begin{lstlisting}
>>> import itertools
>>> x = [1, 2, 3]
>>> y = [8, 9, 10]
>>> for numero in itertools.chain(x, y):
...     print numero
...
1
2
3
8
9
10
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{34. itertools.chain()}
  \scriptsize
  \begin{exampleblock}
    {\footnotesize
      Aplanar una lista de listas, como hicimos antes:}
    \begin{lstlisting}
>>> it = itertools.chain([1, 2], [3], [4, 5], [6, 7, 8])
>>> it
<itertools.chain object at 0x2536590>
>>> list(it)
[1, 2, 3, 4, 5, 6, 7, 8]
>>> list(it)
[]
    \end{lstlisting}
  \end{exampleblock}

  \begin{exampleblock}
  {\footnotesize
    Utilizando * para desempaquetar las sublistas:}
    \begin{lstlisting}
>>> sublistas = [[4, 5], [6, 7]]
>>> list(itertools.chain(*sublistas))
[4, 5, 6, 7]
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{34. itertools.chain()}
  \small
  \begin{alertblock}{}
    \centering
    Pero \structure{chain()} acepta mucho más que listas: le podemos pasar
    \structure{cualquier cosa sobre la que se pueda iterar}. Esto incluye
    generadores, conjuntos, diccionarios y cualquier objeto cuyos
    elementos podemos recorrer de uno en uno.
  \end{alertblock}

  \scriptsize
  \begin{exampleblock}
    {Dos conjuntos:}
    \begin{lstlisting}
>>> s1 = set([1, 2, 3])
>>> s2 = set([6, 5, 4])
>>> list(itertools.chain(s1, s2))
[1, 2, 3, 4, 5, 6]
    \end{lstlisting}
  \end{exampleblock}

  \begin{exampleblock}
    {Diccionaro (claves) y conjunto:}
    \begin{lstlisting}
>>> d1 = {1 : "uno", 2 : "dos"}
>>> s1 = set(["tres", "cuatro"])
>>> list(itertools.chain(d1, d2))
[1, 2, 'cuatro', 'tres']
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{35. functools.partial()}
  \small
  \begin{block}{}
    \centering
    En el módulo \structure{functools}, la función
    \structure{partial()} nos permite \emph{congelar} otra función,
    \structure{fijándole argumentos} de forma que podamos llamarla de
    forma más sencilla y corta.
  \end{block}

  \begin{exampleblock}{}
    \begin{lstlisting}
>>> import functools
>>> eleva_dos = functools.partial(pow, 2)
    \end{lstlisting}
  \end{exampleblock}

\begin{exampleblock}
  {Y ahora usándola:}
    \begin{lstlisting}
>>> eleva_dos(3)
8
>>> eleva_dos(10)
1024
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{35. functools.partial()}
  \small
  \begin{alertblock}{}
    \centering
    Es importante tener presente que los argumentos que nosotros le
    pasamos a la función \emph{congelada} se añaden
    \structure{después} de los que hemos definido en
    \structure{partial()}. Es necesario dar un rodeo si queremos crear
    funciones parciales que añadan los argumentos por el comienzo --
    por ejemplo, para devolver \structure{pow(x, 3)}.
  \end{alertblock}

  \begin{block}
    {\centering Python: Why is functools.partial necessary?}
    \centering \url{http://stackoverflow.com/a/3252425/184363}
  \end{block}

  \begin{block}
    {\centering implementing functools.partial that prepends additional arguments}
    \centering \url{http://stackoverflow.com/q/11831070/184363}
  \end{block}
\end{frame}

\begin{frame}[fragile]{36. Pasando funciones a iter()}
  \begin{block}{}
    \Large
    \centering iter(function, sentinel))
  \end{block}

  \small
  \begin{alertblock}{}
    \centering
    El uso más habitual de \structure{iter()} es pasarle un único
    argumento --- el objeto sobre el que queremos iterar. Pero también
    podemos pasarle una \structure{función}, que es ejecutada una y
    otra vez: en el momento en el que uno de los valores que devuelve
    sea igual a \structure{sentinel}, nos detenemos.
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]{36. Pasando funciones a iter()}
  \small
  \begin{exampleblock}
    {Lee un fichero hasta la primera línea vacía:}
    \begin{lstlisting}
with open('currículum.tex') as fd:
    for linea in iter(fd.readline, '\n'):
        print linea
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{36. Pasando funciones a iter()}
  \small
  \begin{exampleblock}
    {Genera números aleatorios hasta llegar a cero:}
    \begin{lstlisting}
import random

def aleatorio():
    return random.randint(-10, 10)

for numero in iter(aleatorio, 0):
    print numero
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{37. Autocompletado en el intérprete}
  \small
  \begin{block}{}
    \centering
    En nuestro fichero \structure{.pythonrc}, estas líneas bastan para
    habilitar el \structure{autocompletado}, que se activa al pulsar
    tabulador, como estamos acostumbrados a hacer en la línea de
    comandos.
  \end{block}

  \begin{exampleblock}{}
    \begin{lstlisting}
import readline
import rlcompleter
readline.parse_and_bind("tab: complete")
    \end{lstlisting}
  \end{exampleblock}

  \footnotesize
  \begin{alertblock}{}
    \centering
    ¡La variable de entorno \structure{PYTHONSTARTUP} debe apuntar a este fichero!
  \end{alertblock}
\end{frame}

\begin{frame}[fragile]{38. Historia de comandos}
  \small
  \begin{block}{}
    \centering
    También podemos habilitar la historia de \structure{todo lo que
      hemos escrito} en el intérprete de Python, accesibles pulsando
    las \structure{teclas de navegación} vertical. Al igual que en una
    terminal cualquiera, la historia se guarda en un fichero, por lo
    que podemos reusar los comandos \structure{de una sesión a otra}.
  \end{block}

  \footnotesize
  \begin{exampleblock}{}
    \begin{lstlisting}
import atexit
import os.path
import readline

history_file = os.path.expanduser('~/.python_history')
if os.path.exists(history_file):
    readline.read_history_file(history_file)
func = readline.write_history_file
atexit.register(func, history_file)
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{39. Límite de memoria}
  \small
  \begin{block}{}
    \centering
    Antes hemos mencionado que crear una lista de tamaño excesivo
    podría usar \structure{toda la memoria} del ordenador, a veces con
    trágicas consecuencias. Usando esto podemos impedir que Python use
    más del 3/4 de la memoria total de nuestro equipo, abortando la
    ejecución \structure{si sobrepasamos este límite}.
  \end{block}

  \scriptsize
  \begin{exampleblock}{}
    \begin{lstlisting}
def get_ram_size():
    with open('/proc/meminfo', 'rt') as fd:
        regexp = "^MemTotal:\s*(\d+) kB$"
        match = re.match(regexp, fd.read(), re.MULTILINE)
        return int(match.group(1)) * 1024 # kB to bytes
MAX_RAM = get_ram_size() * 0.75
resource.setrlimit(resource.RLIMIT_AS,
                   (MAX_RAM, resource.RLIM_INFINITY))
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\begin{frame}[fragile]{39. Límite de memoria}
  \footnotesize
  \begin{exampleblock}
    {Esto es lo que ocurre entonces si abarcamos demasiado:}
    \begin{lstlisting}
>>> list(xrange(10e12))
Traceback (most recent call last):
  File ``<stdin>'', line 1, in <module>
MemoryError
    \end{lstlisting}
  \end{exampleblock}

  \small
  \begin{block}
    {\centering Por si alguien quiere reusar mi fichero .pythonrc}
    \centering \url{http://github.com/vterron/dotfiles}
  \end{block}
\end{frame}

\begin{frame}[fragile]{40. a, *b, c = range(5)}
  \begin{exampleblock}
    {\centering Un detalle precioso de Py3K}
    \small
    \begin{lstlisting}[escapechar=!]
>>> primero, !\color{blue}{*resto}! = range(5)
>>> primero
0
>>> resto
[1, 2, 3, 4]
>>> primero, !\color{blue}{*resto}!, ultimo = range(10)
>>> primero
0
>>> resto
[1, 2, 3, 4, 5, 6, 7, 8]
>>> ultimo
9
    \end{lstlisting}
  \end{exampleblock}
\end{frame}

\section{You Are Now a Ninja}
\begin{frame}[fragile]{Programadores Python Shaolín}
  \begin{figure}
    \centering
    \includegraphics[height=7cm]{pics/shaolin.jpg}
  \end{figure}
\end{frame}

\end{document}
